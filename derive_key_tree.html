<!DOCTYPE HTML>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<body>
<script src="js_include_files/wordlist_english.js"></script>
<script src="js_include_files/crypto.js"></script>
<script src="js_include_files/noble-secp256k1.js"></script>
<script src="js_include_files/noble-ripemd160.js"></script>
<script>
// Ability check
console.log('test mnemonic word list: ' + wordListArray[1])
// objects to use 3rd party functions
let secp = nobleSecp256k1;
let noble = nobleHashes;

test_keygen();
async function test_keygen(){

	// Generate a key we know is valid
	const sentence = await computeMnemonicPhrase();
	console.log('mnemonic sentence: ' + sentence);
	const seed = await computeSeed512(sentence);
	const hashed_seed = await hmac_sha512(seed);
	const private_key = hashed_seed.substring(0,64);
	const chain_code = hashed_seed.substring(64,128);
	const root_private_key = await compute_extended_key(chain_code, '00' + private_key);
	console.log('root extended private key: ' + root_private_key);
/*
	//depth1
	const results_array = await derive_child_privkey(chain_code, private_key, 2);
	const pubkey_child = await secp.getPublicKey(results_array[0], true);
	const address_child = await getAddress(pubkey_child);
	console.log('address of child key depth1: ' + address_child);
	//depth 2
	const results_array_depth2 = await derive_child_privkey(results_array[1], results_array[0], 2**31+2);
	const pubkey_child_d2 = await secp.getPublicKey(results_array_depth2[0], true);
	const address_child_d2 = await getAddress(pubkey_child_d2);
	console.log('address of child key depth2: ' + address_child_d2);

	// depth 3
	const results_normchild = await derive_child_privkey(results_array_depth2[1], results_array_depth2[0], 3);
	const pubkey_child_d3 = await secp.getPublicKey(results_normchild[0], true);
	const address_child_d3 = await getAddress(pubkey_child_d3);
	console.log('address of child key depth3: ' + address_child_d3);
*/
	let 
	// testing code as I build
	node_keypair = derive_key_tree('cat dog tree', 'm/43h/3');
}

// Takes a key tree derivation notation string, like m/31h/2345/1h,
// and a mnemonic sentence for the seed.
// and returns the keypair at that tree location.
async function derive_key_tree(mnemonic, key_tree_str){
	// Decode the key tree, associating an index with each level
	// build an array where the array index matches the depth level
	// each index returns a 2 deep array with 0th returning privkey
	// and 1st returning chain code.
	//
	// how do we know the root key? derive from a mnemonic sentence.
	// first build an array with the key index corresponding to the arr index.
	// use regex.
	let keypair_arr = new Array;
	let tree_index_arr = new Array;

	// load array to process index values
	tree_index_arr = key_tree_str.split('/');
	for(i=0; i < tree_index_arr.length; i++){
		console.log('i: ' + i + ' tree index: ' + tree_index_arr[i]);
	}


/*
	// make sure we're starting with 'm' and in the proper format
	if( mnemonic.match(/^m(\/[0-9]+h?)+/){
		// root index is always 0
		key_index_arr.push(0);
		// strip of the m
		mnemonic = mnemonic.substring(1);
		// strip off each index and move to the next in the mnemonic str.
		while( mnemonic.match(/^\/([0-9]+h?)/ ){
			// convert the h into 2**31 added to the number.
			if

		}

	}else{
		throw('derivation tree string formatted incorrectly.');
	}
*/

    let children_keys = new Array;
    //children_keys[0] = child_privkey_hex;
    //children_keys[1] = child_chain_code;

    return children_keys;
}




</script>

</body>

</html>
