<!DOCTYPE HTML>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<body>
<script src="js_include_files/wordlist_english.js"></script>
<script src="js_include_files/crypto.js"></script>
<script src="js_include_files/noble-secp256k1.js"></script>
<script src="js_include_files/noble-ripemd160.js"></script>
<script>
// Ability check
console.log('test mnemonic word list: ' + wordListArray[1])
// objects to use 3rd party functions
let secp = nobleSecp256k1;
let noble = nobleHashes;

test_keygen();
async function test_keygen(){
/*
	// Generate a key we know is valid
	const sentence = await computeMnemonicPhrase();
	console.log('mnemonic sentence: ' + sentence);
	const seed = await computeSeed512(sentence);
	const hashed_seed = await hmac_sha512(seed);
	const private_key = hashed_seed.substring(0,64);
	const chain_code = hashed_seed.substring(64,128);
	const root_private_key = await compute_extended_key(chain_code, '00' + private_key);
	console.log('root extended private key: ' + root_private_key);
/*
	//depth1
	const results_array = await derive_child_privkey(chain_code, private_key, 2);
	const pubkey_child = await secp.getPublicKey(results_array[0], true);
	const address_child = await getAddress(pubkey_child);
	console.log('address of child key depth1: ' + address_child);
	//depth 2
	const results_array_depth2 = await derive_child_privkey(results_array[1], results_array[0], 2**31+2);
	const pubkey_child_d2 = await secp.getPublicKey(results_array_depth2[0], true);
	const address_child_d2 = await getAddress(pubkey_child_d2);
	console.log('address of child key depth2: ' + address_child_d2);

	// depth 3
	const results_normchild = await derive_child_privkey(results_array_depth2[1], results_array_depth2[0], 3);
	const pubkey_child_d3 = await secp.getPublicKey(results_normchild[0], true);
	const address_child_d3 = await getAddress(pubkey_child_d3);
	console.log('address of child key depth3: ' + address_child_d3);
*/
	// testing code as I build
	let m_sentence = await computeMnemonicPhrase();
	//node_keypair = await derive_key_tree('cat dog tree', 'm/43h/3/1000h/2000/4000/10000h');
	//node_keypair = await derive_key_tree(m_sentence, 'm/43h/3/1000h/2000/4000/10000h/2000000000');
	node_keypair = await derive_key_tree(m_sentence, 'm/3h');
	let address = await get_address_from_keypair(node_keypair);
	console.log('result address: ' + address);
}

// Takes a key tree derivation notation string, like m/31h/2345/1h,
// and a mnemonic sentence for the seed.
// and returns the keypair at that tree location.
async function derive_key_tree(mnemonic, key_tree_str){
	// Decode the key tree, associating an index with each level
	// build an array where the array index matches the depth level
	// each index returns a 2 deep array with 0th returning privkey
	// and 1st returning chain code.
	//
	// how do we know the root key? derive from a mnemonic sentence.
	// first build an array with the key index corresponding to the arr index.
	// use regex.
	let tree_index_arr = new Array;

	console.log('input- mnemonic: ' + mnemonic);
	console.log('input- key_tree_str: ' + key_tree_str);
	
	// check validity of the mnemonic
	if( await verifyMnemonicPhrase(mnemonic) ){
		console.log('mnemonic phrase verified!');
	}else{
		console.log('mnemonic phrase INVALID!');
	}

	// load array to process index values
	tree_index_arr = key_tree_str.split('/');
	// this function should only work on private keys
	if( tree_index_arr[0] != 'm' ){
		console.log('invalid key tree format!');
	}
	// can only compute depth to 255 values past root
	if( tree_index_arr.length > 255){
		console.log('key tree invalid! max depth is 256');
	}

	// convert hardened notation into numbers and check if valid
	for(i=1; i < tree_index_arr.length; i++){
//		console.log('i: ' + i + ' tree index: ' + tree_index_arr[i]);
		//test = tree_index_arr[i];
		if( /[^0-9h]/.test(tree_index_arr[i]) ){
			console.log('Detected invalid key tree character!');
		// convert hardened index to number for easier use
		} else if( /^[0-9]+h$/.test(tree_index_arr[i]) ){
			index = tree_index_arr[i].match(/^([0-9]+)h$/);
			tree_index_arr[i] = parseInt(index) + 2**31;
		// continue, normal index is in proper form
		}else if( /^[0-9]+$/.test(tree_index_arr[i]) ){
			//index_n = tree_index_arr[i].match(/^([0-9]+)$/);
			tree_index_arr[i] = parseInt(tree_index_arr[i]);
		}else{// the 'h' is in the wrong spot 
			console.log('key tree is invalid!');
		}
//		console.log('resulting index value: ' + tree_index_arr[i]);
	}

	// build keypair array
	let keypair_arr = new Array;
	// start with root master key
	keypair_arr.push(await get_root_keypair(mnemonic));
	console.log('root extended key: ' + await compute_extended_key(keypair_arr[0][1], '00' + keypair_arr[0][0]));
	// compute and store the rest
	for(j=1; j < tree_index_arr.length; j++){
		keypair_arr.push(await derive_child_privkey(keypair_arr[j-1][1], keypair_arr[j-1][0], tree_index_arr[j]));
	}

//	console.log('built keypair_arr:' + keypair_arr);
//	console.log('target keypair:' + keypair_arr[tree_index_arr.length-1]);	
	
    return keypair_arr[tree_index_arr.length-1];
}

/*
	// build full keyset array (privkey, chain code, address, xpriv, xpub)
	let full_keyset_arr = new Array;
	// start with root master key
	const root_keypair = await get_root_keypair(mnemonic);
	const root_pubkey = await secp.getPublicKey(root_keypair[0], true);
	const root_address = await getAddress(root_pubkey);
	const root_xpriv = await serialize_key(root_keypair[1], '00' + root_keypair[0]);
	const root_xpub = await serialize_key(root_keypair[1], root_pubkey);
	let root_keyset_arr = new Array;
	root_keyset_arr[0] = root_keypair;
	root_keyset_arr[1] = root_pubkey;
	root_keyset_arr[2] = root_address;
	root_keyset_arr[3] = root_xpriv;
	root_keyset_arr[4] = root_xpub;

	full_keyset_arr.push( root_keyset_arr );
	
	for(j=1; j < tree_index_arr.length; j++){

		curr_keypair = await get_root_keypair(mnemonic);
		curr_pubkey = await secp.getPublicKey(root_keypair[0], true);
		curr_address = await getAddress(root_pubkey);
		curr_xpriv = await serialize_key(root_keypair[1], '00' + root_keypair[0]);
		curr_xpub = await serialize_key(root_keypair[1], root_pubkey);


        keypair_arr.push(await derive_child_privkey(keypair_arr[j-1][1], keypair_arr[j-1][0], tree_index_arr[j]));
    }
*/


</script>

</body>

</html>
