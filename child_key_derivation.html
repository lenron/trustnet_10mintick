<!DOCTYPE HTML>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<body>
<script src="js_include_files/wordlist_english.js"></script>
<script src="js_include_files/crypto.js"></script>
<script src="js_include_files/noble-secp256k1.js"></script>
<script src="js_include_files/noble-ripemd160.js"></script>
<script>
// Ability check
console.log('test mnemonic word list: ' + wordListArray[1])
var secp = nobleSecp256k1;
var noble = nobleHashes;

test_keygen();
async function test_keygen(){

	//var private_key = 'f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9';
	// Generate a key we know is valid
	const sentence = await computeMnemonicPhrase();
	console.log('mnemonic sentence: ' + sentence);
	const seed = await computeSeed512(sentence);
	console.log('seed: ' + seed);
	const hashed_seed = await hmac_sha512(seed);
	const private_key = hashed_seed.substring(0,64);
	const chain_code = hashed_seed.substring(64,128);
	const root_private_key = await compute_extended_key(chain_code, '00' + private_key);
	console.log('root extended private key: ' + root_private_key);

	// use test values from learnme to make sure we're doing this right.
	//parent_chain_code = '463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b';
	//parent_key = 'f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9';

	// use index 2^31 or greater to derive hardened child.
	const results_array = await derive_child_key(chain_code, private_key, 2**31);
	console.log('computed child key: ' + results_array[0]);
	console.log('computed chain code: ' + results_array[1]);

	// check secp
	// 'true' option returns a compressed public key.
	//const public_key = await secp.getPublicKey(private_key, true);
	//console.log('public key: ' + public_key);

	//const address = await getAddress(public_key);
	//console.log('address of master pubkey: ' + address);

	// getting an 'Error: Expected 32 bytes of private key' error here sometimes.
	const pubkey_child = await secp.getPublicKey(results_array[0], true);
	console.log('public child key: ' + pubkey_child);
	const address_child = await getAddress(pubkey_child);
	console.log('address of child pubkey: ' + address_child);

}

// getAddress takes a public key in a hex string as input and
// returns a base58 encoded P2PKH (prefix 1) address.
async function getAddress(public_key){
	// run a SHA256 hash on the public key
	const pubkey_buf = hex_string_to_ArrayBuffer(public_key);
    const hashBuffer256 = await crypto.subtle.digest('SHA-256', pubkey_buf);
	const pubkey_uint8_arr = new Uint8Array(hashBuffer256);

	// Take the result of the SHA256 hash and run a ripemd160 hash on it.
	// ripemd160 takes Uint8Array and returns a Uint8Array.
	const pubkey_h160_uint8 = await noble.ripemd160(pubkey_uint8_arr);
	// convert uint8 array to a 2 digit (1 byte) hex array.
	var pubkey_h160 = new Array;
	for(i=0; i < pubkey_h160_uint8.length; i++){
		pubkey_h160.push(pubkey_h160_uint8[i].toString(16).padStart(2, '0'));
	}

	// compute a checksum of data that includes the prefix
	const data = '00' + pubkey_h160.join('');
	const checksum = await computeChecksum(data);
	const payload = data + checksum;
	return encode_b58(payload);
}

// Convert an input of Uint8Array to a returned 


//Convert hex string to array of unsigned 8-bit integers and return the ArrayBuffer.
//A compressed 33 byte secp public key will return a 256 bit ArrayBuffer number.
//From: https://gist.github.com/don/871170d88cf6b9007f7663fdbc23fe09
function hexStringToArrayBuffer(hexString) {
    // remove the leading 0x (modified this from original for ECC public keys).
    hexString = hexString.replace(/^0./, '');

    // ensure even number of characters
    if (hexString.length % 2 != 0) {
        console.log('WARNING: expecting an even number of characters in the hexString');
    }

    // check for some non-hex characters
    var bad = hexString.match(/[G-Z\s]/i);
    if (bad) {
        console.log('WARNING: found non-hex characters', bad);
    }

    // split the string into pairs of octets
    var pairs = hexString.match(/[\dA-F]{2}/gi);

    // convert the octets to integers
    var integers = pairs.map(function(s) {
        return parseInt(s, 16);
    });
    var array = new Uint8Array(integers);

    //The buffer method called here returns the ArrayBuffer.
    return array.buffer;
}



// Takes parent private key and chain code and computes child key and chain code.
// index input is a number, both parent inputs are hex strings.
// I'm setting this function up to have the capability to derive public as well as private
// child keys.  Indexes 2^31 to 2^32-1 will derive hardened children keys (able to derive child
// private keys). Indexes 0 to 2^31-1 will derive normal children keys.
// output array[0] == child key, output array[1] == child chain code.
async function derive_child_key(parent_chain_code, parent_key, index) {
	// index of hardened keys must be between 2^31 and 2^32 - 1
	// starts at m/2147483648
	// I think this will have to be computed 
	//const index = 2147483648;

	// The order of the elliptic curve defined in secp256k1 is a constant.
	const n_order_hex = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141';
	// To do any number processing in native javascript, we have to use a BigInt.
	var n_order_int = BigInt('0x' + n_order_hex);

	// index must be in hex string for concatenation
	index_hex = num2hex(index);
	console.log('index_hex: ' + index_hex);

	// use test values from learnme to make sure we're doing this right.
	//parent_chain_code = '463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b';
	//parent_key = 'f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9';

	// set up HMAC hash 
	const data = '00' + parent_key + index_hex;
	const key = parent_chain_code;

	const intermediate_key = await hmac_sha512(data, key);
	console.log('intermediate_key: ' + intermediate_key);
	const ikey_left = intermediate_key.substring(0,64);
    const child_chain_code = intermediate_key.substring(64,128);
	console.log('ikey left: ' + ikey_left);
	console.log('chain code: ' + child_chain_code);

	// BIP 32 specifies that derived chain codes >= the order (n) are invalid.
	if (BigInt('0x' + child_chain_code) >= n_order_int){
		throw 'Chain code is greater than the order of the curve. Try the next index.';
		// Recalculate using the next index.
	}

	// Use scalar addition here
	var child_key_int = BigInt(Number.MAX_SAFE_INTEGER);
	child_key_int = (BigInt('0x' + ikey_left) + BigInt('0x' + parent_key)) % n_order_int;
	child_key_hex = num2hex(child_key_int);
	var children_keys = new Array;
/*
	if (child_key_hex.length != 64){
		children_keys[0] = '0' + child_key_hex;
		console.log('\n\n\n\n\n\n\n\n\n\n\n');
	}else{
		children_keys[0] = child_key_hex;
	}
*/
	
	children_keys[0] = child_key_hex;
	children_keys[1] = child_chain_code;
	
	return children_keys;
}

function num2hex(integer){
	return integer.toString(16);//.padStart(2, '0')
}

// Takes hex strings as input.
// Outputs the xprv key encoded in base58.
// For Master root extended private key, we start at 0 for several values.
async function compute_extended_key(chain, key, depth = '00', index = '00000000', fingerprint = '00000000'){
	var version = '';
	// Check if key is private
	if( key.substring(0,2) == '00'){
		// key is private, starte encoded str with xprv
    	version = '0488ADE4';
	}else{	// key is public, start encoded str with xpub
    	version = '0488B21E';
	}

    const serialized = version + depth + fingerprint + index + chain + key;
    console.log('serialized: ' + serialized);
    const checksum = await computeChecksum(serialized);
    var extended_key = encode_b58(serialized + checksum);
    //console.log('the xprv: ' + extended_private_key);
    return extended_key;
}

// Converts an inputted hex string into a base58 encoded number.
// This function is for bitcoin, so leading '00's will be converted to a 1.
function encode_b58(hex_number) {
    // Set of base58 chars
    const base58 = [1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];

    // Convert hex string into a number for processing.
    // Default numbers in java are computed to only 16 significant digits.
    var num = BigInt(Number.MAX_SAFE_INTEGER);
    // 0x tells BigInt that the hex_number is in hexadecimal
    input = '0x' + hex_number;
    num = BigInt(input);

    // explain why this works as a number base conversion.
    // We use a math trick to convert the number into base 58 that involves taking the remainder
    // of a modulus operation and integer division.
    var remainder = '';
    // Create empty string to hold encoded base58 chars.
    var encoded_buffer = '';
    while(num > 0){
        // The remainder represents the next base58 digit.
        remainder = num % BigInt(58);
        // Add the corresponding base58 digit on the left of our encoded string.
        encoded_buffer = base58[remainder] + encoded_buffer;
        // integer division
        num = num/BigInt(58);
    }

    // Bitcoin spec requires us to convert leading zero pairs to 1's.
    // When converted to a number, leading zeros are ignored.
    // Thus we can convert them to 1's from the original hex string and
    // attach them after the initial base58 encoding.
    var num_leading_zero_pairs = 0;
    const regex = /^00/g;
    while (hex_number.match(regex)){
        hex_number = hex_number.substring(2);
        num_leading_zero_pairs++;
    }
    for(i=num_leading_zero_pairs; i > 0; i--){
        encoded_buffer = '1' + encoded_buffer;
    }

    return encoded_buffer;
}


// Takes no inputs
// Returns array containing mnemonic sentence, seed, xprv respectively
async function mnemonic_gen_to_xprv (){

    const mne_sentence = await computeMnemonicPhrase();

    if( verifyMnemonicPhrase(mne_sentence)){
        console.log('mnemonic sentence verified!');
    }else{
        console.log('mnemonic sentence INVALID!');
    }

    seed512_hex = await computeSeed512(mne_sentence);
    hmac_sha512_hashed_seed = await hmac_sha512(seed512_hex);
    private_key_256 = hmac_sha512_hashed_seed.substring(0,64);
    chain_code = hmac_sha512_hashed_seed.substring(64,128);
    //console.log('hashed seed: ' + hmac_sha512_hashed_seed);
    //console.log('private key: ' + private_key_256);
    //console.log('chain code: ' + chain_code);

    xprv_key = await compute_extended_key(chain_code, private_key_256);

    var return_arr = new Array();
    return_arr[0] = mne_sentence;
    return_arr[1] = seed512_hex;
    return_arr[2] = xprv_key;

    return return_arr;
}

// I can't think of a reason we would need to extract the entropy bits from the mnemonic phrase.
// Besides verification. Returns true if verified, false otherwise.
async function verifyMnemonicPhrase(phrase){
    const phraseArray = phrase.split(' ');

    // Convert to array of 11 bit binary numbers
    indexArray = new Array;
    for(var i=0; i < phraseArray.length; i++){
        if( wordListArray.indexOf(phraseArray[i]) < 0){
            console.warn('Word: ' + phraseArray[i] + ' not found in mnemonic word list!');
            return false;
        }else{
            indexArray.push(wordListArray.indexOf(phraseArray[i]));
        }
    }
    // Convert to an array of binary strings.
    const binaryIndexArray = indexArray.map(b => b.toString(2).padStart(11, '0'));

    // Strip off checksum.
    const binaryIndexStr = binaryIndexArray.join('');
    // Capture checksum bits.
    const checksum = binaryIndexStr.slice(-4);
    // Remove checksum bits from the bits that represent the mnemonic phrase.
    const wordBitsStr = binaryIndexStr.substring(0, binaryIndexStr.length-4);
    const wordBitsArray = new Array;
    for(var i=0; i < wordBitsStr.length; i+=8){
        wordBitsArray.push(wordBitsStr.substring(i,i+8));
    }

    // Convert the 8-bit word strings into numbers.
    const entropyNumberArr = new Array;
    for(var i=0; i < wordBitsArray.length; i++){
        entropyNumberArr.push(parseInt(wordBitsArray[i], 2));
    }

    // Take the SHA-256 hash of the resulting numbers.
    const entropyBytesUint8 = new Uint8Array(entropyNumberArr);
    const hashArray = await get256HashArray(entropyBytesUint8);

    // Convert resulting hash and compare checksum bits
    const hashBinArr = numberArrToBinaryStrArr(hashArray);
    // The checksum is represented by the first 4 bits of the hash.
    const checksum_verify = hashBinArr[0].substring(0,4);
    if(checksum == checksum_verify){
        return true;
    }else{
        return false;
    }
}

// Generate a mnemonic phrase with entropy generated from the subtlecrypto library.
// Returns a string of mnemonic words delimited by a single space.
async function computeMnemonicPhrase(){
    // Create array of 16 randomly generated 8-bit integers.
    var rand_entropy = new Uint8Array(16);
    crypto.getRandomValues(rand_entropy);

    // Create checksum from SHA-256 hash, using the first 4 bits.
    const hashArray = await get256HashArray(rand_entropy);
    // Convert array of numbers to an array of 8-bit binary strings.
    const hashBinArr = numberArrToBinaryStrArr(hashArray);
    const checksum = hashBinArr[0].substring(0,4);

    // Add the checksum to the end of the random sequence of 8-bit numbers.
    // Need to convert entropy to an untyped array for it to work.
    const entropyArray = Array.from(rand_entropy);
    const entropyAndChecksum = numberArrToBinaryStrArr(entropyArray).join('') + checksum;

    // Divide the resulting sequence into sections of 11 bits.
    const numberWordArray = new Array;
    for(var i=0; i < entropyAndChecksum.length; i+=11){
        numberWordArray.push(entropyAndChecksum.substring(i,i+11));
    }

    // Produce 12 words representing the mnemonic code.
    const wordArray = new Array;
    for(var n=0; n < numberWordArray.length; n++){
        // Use the 11-bit numbers to index an array of 2048 predefined words.
        wordArray.push(wordListArray[parseInt(numberWordArray[n], 2)]);
    }

    return wordArray.join(' ');
}

// Takes a mnemonic sentence and possibly a password as input.
// Outputs the computed seed in a hex string.
async function computeSeed512(mnemonicPhrase, in_password){
    if( typeof password !== 'undefined'){
        password = in_password;
    }else{
        password = '';
    }
    const salt = 'mnemonic' + password;
    const normsalt = salt.normalize('NFKD', 'utf8');
    // For PBKDF2 to work properly, inputs must be in uint8 ArrayBuffer format.
    const saltArrayBuffer = new TextEncoder().encode(normsalt);
    const phraseArrayBuffer = new TextEncoder().encode(mnemonicPhrase);

    // Construct pbkdf2params object.
    const pbkdf2params_object =
        {
            "name": "PBKDF2",       // Identifies this as a pbkdf2params object.
            salt: saltArrayBuffer,  // Cryptographic salt.
            "iterations": 2048,     // Number of iterations.
            "hash": "SHA-512"       // Hash digest algorithm identifier.
        };
    //CryptoKey object needed for deriveBits() to perform PBKDF2.
    const pbkdf2_cryptokey = await crypto.subtle.importKey(
        //Format of data. Raw is used for HMAC keys.
        "raw",
        //Raw key supplied as ArrayBuffer.
        phraseArrayBuffer,
        // Dictionary object defining the type of key to import.
        "PBKDF2",
        // W3C requires this to be 'false' for PBKDF2.
        false,
        //How the key will be used.
        ["deriveBits"]

    );

    //ArrayBuffer holding 512 bits produced from PBKDF2.
    const derived_512_bits_from_PBKDF2 = await crypto.subtle.deriveBits(
        //Specific algorithm. In our case: Pbkdf2Params dictionary object.
        pbkdf2params_object,
        //CryptoKey object. For PBKDF2, comes from importKey().
        pbkdf2_cryptokey,
        //The number of bits to derive.
        512
    );

    return buf2hex(derived_512_bits_from_PBKDF2);
}

// Takes hex string as input and outputs a hex string of 4 bytes.
async function computeChecksum(payload) {

    // Encode payload data into ArrayBuffer.
    const hexArrayBuffer = hex_string_to_ArrayBuffer(payload);

    // Bitcoin base58check uses a double sha-256 hash.
    const hashBuffer256 = await crypto.subtle.digest('SHA-256', hexArrayBuffer);
    const double256 = await crypto.subtle.digest('SHA-256', hashBuffer256);
/*
	test = new Uint8Array(double256);
	console.log('buffer output: ' + test);
	test_hex = new Array;
	for(i=0; i<test.length; i++){
		test_hex.push(test[i].toString(16).padStart(2, '0'));
	}
	console.log('test_hex: ' + test_hex);
*/
    hashHex = buf2hex(double256);
	//console.log('buf2hex output: ' + hashHex);

    return hashHex.substring(0,8);
    //return checksum;
}

// This function converts a hex string into an ArrayBuffer for hash processing.
function hex_string_to_ArrayBuffer(hexString){

    // convert to a number array representing the hex bytes.
    const hexBytesArray = new Array;
    for(var i=0; i < hexString.length; i+=2){
        hexBytesArray.push(parseInt(hexString.substring(i, i+2), 16));
    }
    const hexArrayBuffer = new Uint8Array(hexBytesArray);

    return hexArrayBuffer;
}

// takes a buffer as input and returns a hex string
function buf2hex(buffer) { // buffer is an ArrayBuffer
  return [...new Uint8Array(buffer)]
      .map(x => x.toString(16).padStart(2, '0'))
      .join('');
}

function numberArrToBinaryStrArr(numberArray){
    return numberArray.map(b => b.toString(2).padStart(8, '0'));
}


async function get256HashArray(entropy){
    const hashBuffer = await crypto.subtle.digest('SHA-256', entropy);      // hash the message
    return Array.from(new Uint8Array(hashBuffer));                          // convert buffer to byte array
}

// Takes hex string(s) as input and outputs a hex string.
// Performs the HMAC-SHA512 hash.
async function hmac_sha512(data, key){
    // If no key is given, we are computing the root extended private key
    if (typeof key == 'undefined'){
        // Encode the key.
        const key = 'Bitcoin seed';
        var key_enc = new TextEncoder().encode(key);
    }else{
        // Any other input should be a hex string.
        var key_enc = hex_string_to_ArrayBuffer(key);
    }

    // Encode the hex data
    const data_encoded = hex_string_to_ArrayBuffer(data);

    //CryptoKey object needed for deriveBits() to perform PBKDF2.
    const imported_key = await crypto.subtle.importKey(
        "raw", // raw format of the key - should be Uint8Array
        key_enc,
        { // algorithm details
            name: "HMAC",
            hash: {name: "SHA-512"}
        },
        false, // export = false
        ["sign"] // what this key can do
    );

    // Perform the HMAC-SHA512 hash
    const signature = await crypto.subtle.sign(
        "HMAC",
        imported_key,
        data_encoded
    );
    return buf2hex(signature);
}

</script>

</body>

</html>
