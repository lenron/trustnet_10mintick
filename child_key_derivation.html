<!DOCTYPE HTML>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<body>
<script src="js_include_files/wordlist_english.js"></script>
<script src="js_include_files/crypto.js"></script>
<script src="js_include_files/noble-secp256k1.js"></script>
<script src="js_include_files/noble-ripemd160.js"></script>
<script>
// Ability check
console.log('test mnemonic word list: ' + wordListArray[1])
let secp = nobleSecp256k1;
let noble = nobleHashes;

test_keygen();
async function test_keygen(){

	//let private_key = 'f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9';
	// Generate a key we know is valid
	const sentence = await computeMnemonicPhrase();
	console.log('mnemonic sentence: ' + sentence);
	const seed = await computeSeed512(sentence);
	console.log('seed: ' + seed);
	const hashed_seed = await hmac_sha512(seed);
	const private_key = hashed_seed.substring(0,64);
	const chain_code = hashed_seed.substring(64,128);
	const root_private_key = await compute_extended_key(chain_code, '00' + private_key);
	console.log('root extended private key: ' + root_private_key);

	// use test values from learnme to make sure we're doing this right.
	//parent_chain_code = '463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b';
	//parent_key = 'f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9';

	// use index 2^31 or greater to derive hardened child.
	const results_array = await derive_child_key(chain_code, private_key, 2**31+1);
	console.log('computed child key: ' + results_array[0]);
	console.log('computed chain code: ' + results_array[1]);

	// check secp
	// 'true' option returns a compressed public key.
	//const public_key = await secp.getPublicKey(private_key, true);
	//console.log('public key: ' + public_key);

	//const address = await getAddress(public_key);
	//console.log('address of master pubkey: ' + address);

	// getting an 'Error: Expected 32 bytes of private key' error here sometimes.
	const pubkey_child = await secp.getPublicKey(results_array[0], true);
	console.log('public child key: ' + pubkey_child);
	const address_child = await getAddress(pubkey_child);
	console.log('address of child pubkey: ' + address_child);

}

// Takes parent private key and chain code and computes child key and chain code.
// index input is a number, both parent inputs are hex strings.
// I'm setting this function up to have the capability to derive public as well as private
// child keys.  Indexes 2^31 to 2^32-1 will derive hardened children keys (able to derive child
// private keys). Indexes 0 to 2^31-1 will derive normal children keys.
// output array[0] == child key, output array[1] == child chain code.
async function derive_child_key(parent_chain_code, parent_key, index) {
	// index of hardened keys must be between 2^31 and 2^32 - 1
	// starts at m/2147483648
	// I think this will have to be computed 
	//const index = 2147483648;

	// The order of the elliptic curve defined in secp256k1 is a constant.
	const n_order_hex = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141';
	// To do any number processing in native javascript, we have to use a BigInt.
	let n_order_int = BigInt('0x' + n_order_hex);

	// index must be in hex string for concatenation
	index_hex = num2hex(index);
	console.log('index_hex: ' + index_hex);

	// use test values from learnme to make sure we're doing this right.
	//parent_chain_code = '463223aac10fb13f291a1bc76bc26003d98da661cb76df61e750c139826dea8b';
	//parent_key = 'f79bb0d317b310b261a55a8ab393b4c8a1aba6fa4d08aef379caba502d5d67f9';

	// set up HMAC hash 
	const data = '00' + parent_key + index_hex;
	const key = parent_chain_code;

	const intermediate_key = await hmac_sha512(data, key);
	console.log('intermediate_key: ' + intermediate_key);
	const ikey_left = intermediate_key.substring(0,64);
    const child_chain_code = intermediate_key.substring(64,128);
	console.log('ikey left:  ' + ikey_left);
	console.log('chain code: ' + child_chain_code);

	// BIP 32 specifies that derived chain codes >= the order (n) are invalid.
	if (BigInt('0x' + child_chain_code) >= n_order_int){
		throw 'Chain code is greater than the order of the curve. Try the next index.';
	}

	// Use scalar addition here
	let child_key_int = BigInt(Number.MAX_SAFE_INTEGER);
	child_key_int = (BigInt('0x' + ikey_left) + BigInt('0x' + parent_key)) % n_order_int;
	let child_key_hex = num2hex(child_key_int);

	// Make sure the key is 32 bytes!
	child_key_hex = child_key_hex.padStart(64, '0');
	
	let children_keys = new Array;
	children_keys[0] = child_key_hex;
	children_keys[1] = child_chain_code;
	
	return children_keys;
}

</script>

</body>

</html>
