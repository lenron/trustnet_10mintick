<!DOCTYPE HTML>
<html>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<body>

<script src="wordlist_english.js"></script>
<script src="crypto.js"></script>
<script>
console.log(wordListArray[0])

// I found some code and direction which looks promising at
// https://learnmeabitcoin.com/technical/extended-keys#serialization
// the xprv prefix is the same as on ian's generator.

// Let's see if we can compute the same checksum that is computed here
// https://learnmeabitcoin.com/technical/checksum

input = '0488ade4000000000000000000a5877bb24b78d82af212fae3474dafe275383c8ad6929d1e41b0058d89129aba001a0000814dafc5a3695629bf458c3d2f90f0e995d1bb5dbb7c1dd6c50fdde720';
expected = 'dc7a3ddb';
computeChecksum(input);

// result: dc7a3ddb32f066e669065b8b5f7a57cb9f59c7256f8b8aac22a7db663e5079d8
// taking the first 4 bytes: dc7a3ddb
// Success! Now we know our computeChecksum function works. Moving on...
// 
// Next step, figure out what exactly is going on in the HMAC function.
// In section 1, also at https://learnmeabitcoin.com/technical/extended-keys#serialization
// Like the salt for PBKDF2, HMAC-SHA512 wants a key. In bitcoin's case: 'Bitcoin seed'
// I found a subtlecrypto implementation here 
// https://stackoverflow.com/questions/47329132/how-to-get-hmac-with-crypto-web-api

async function hmac_sha512(data){
	// Encode the key.
	const key = 'Bitcoin seed';
	const key_enc = new TextEncoder().encode(key);

	// Encode the hex data
	const data_encoded = hex_string_to_ArrayBuffer(data);

	const imported_key = window.crypto.subtle.importKey(
	    "raw", // raw format of the key - should be Uint8Array
		key_enc, 
		{ // algorithm details
			name: "HMAC",
			hash: {name: "SHA-512"}
		},
		false, // export = false
		["sign", "verify"] // what this key can do
	)

	const signature = await window.crypto.subtle.sign(
        "HMAC",
        imported_key,
        data_encoded
    )
	console.log('signature: ' + buf2hex(signature));
}

async function computeChecksum(payload) {

	// Encode payload data into ArrayBuffer.
	const hexArrayBuffer = hex_string_to_ArrayBuffer(payload);

    const hashBuffer256 = await crypto.subtle.digest('SHA-256', hexArrayBuffer);
    const double256 = await crypto.subtle.digest('SHA-256', hashBuffer256);
    const hashArray = Array.from(new Uint8Array(double256));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

    console.log(hashHex);
    return hashHex;	
}

// This function could probably be condensed one more line.
function hex_string_to_ArrayBuffer(hexString){

    // convert to hex str array
    const hexStringArray = new Array;
    for(var i=0; i < hexString.length; i+=2){
        // I think this might be where the error is.
        hexStringArray.push(hexString.substring(i, i+2));
        //console.log(
    }
    //console.log('hex string array: ' + hexStringArray);

    const hexBytesArray = new Array;
    for(var i=0; i < hexStringArray.length; i++){
        hexBytesArray.push(parseInt(hexStringArray[i], 16));
    }
    //console.log('number array: ' + hexBytesArray);

    const hexArrayBuffer = new Uint8Array(hexBytesArray);
    //console.log('pay_and_pre_uint8: ' + hexArrayBuffer);

	return hexArrayBuffer;
}


</script>

</body>

</html>
